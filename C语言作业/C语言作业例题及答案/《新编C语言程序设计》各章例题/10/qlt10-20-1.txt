#include <stdio.h>
#include <stdlib.h>
typedef struct Node {
   int data;
   struct Node *next;
}NODE;
NODE *createlist()    //正序建链表
{  int ch;
   NODE *last=NULL;
   NODE *p,*head=NULL;
   while (ch!=0){
      p=(NODE*)malloc(sizeof(NODE));
      scanf("%d",&ch); p->data=ch; p->next=NULL;
      if(head==NULL){
          head=p;last=p;
      }
      else { last->next=p;last=p; }
   }
   return head;
}
NODE *compress(NODE *head) 
{  NODE *ptr,*q;
   ptr =head->next; /*取得第一个元素结点的指针 */
   while(ptr&& ptr->next){
      q = ptr->next;
      while(q&&(q->data==ptr->data)) { /*处理重复元素 */
         ptr->next=q->next;
         free(q);
         q=ptr->next;
      }
      ptr=ptr->next;
   }
   return (head);
}
void out(NODE *head){
   NODE *ptr;
   ptr =head;   /*取得第一个元素结点的指针 */
   printf("处理后链表是：\n");
   while(ptr->next){
      printf("%3d",ptr->data);
      if(ptr->next!=NULL) ptr= ptr->next;
   }
}
void main()
{  NODE *list,*list1;
   printf("请输入链表的值(0-结束输入)：\n "); 
   list=createlist();
   list1=compress(list);
   out(list1); printf("\n"); //输出链表
}
运行程序，读者会发现，程序只能删除链表中相邻的重复元素而不能删除不相邻的链表重复元素。若替换成如下compress函数，读者再运行实践，看是否可以了？
NODE *compress(NODE *head) 
{  NODE *ptr,*q,*q2;
   ptr =head->next; /*取得第一个元素结点的指针 */
   while(ptr&& ptr->next){
      q2=ptr;q = ptr -> next; //q2,q为下一循环语句处理中需要的一前一后两指针
      while(q) {  /*处理整个链表中重复元素 */
         if (q->data==ptr->data){
            q2->next= q -> next;
            free(q);       //注意：是释放q指向的结构体存储单元，并非消除q
            q = q2 -> next;//q重新指向下一个结点
         }else{q2=q;q=q->next;}  //q2,q相邻后一个结点
      }
      ptr= ptr->next;
   }
   return (head);
}
