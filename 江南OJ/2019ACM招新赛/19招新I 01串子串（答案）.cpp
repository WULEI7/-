/*首先因为每次只能翻转最大的01串，也就是说其实具体这一串0或者1有多长根本无所谓。
也就是说0000111110000完全等价于010。
然后我们只要讨论01相间的情况。
如果翻转中间的部分，比如把中间的一个1变成0， 那么其实就是…101…→…111…而这三个1等价于一个1。同理0变成1也是一样的。所以其实翻转任意中间的数字其实就是删掉一对相邻的0和1。
然后如果翻转最边上的数字呢？和上面的讨论类似，我们会发现其实就是删掉这个数字。比如101010翻转最右边的0，就是101010→101011→10101
有了上面的条件再来看这道题。如果对于先手，字符串两边分别是0和1的话，他可以把那个0划掉。然后无论对手怎么操作，他都可以始终保持两端都是1，直到最后。同样如果两端本来就是1的话只要随便划掉中间的一个数字就可以了。
然而如果两端都是0的话，相反后手可以始终保持两端都是0，直到最后。
所以只要看一下是不是两端都是0就好了。*/ 
#include <bits/stdc++.h>
using namespace std;
const int maxn = 105;
int main()
{
        char s[maxn];
        scanf("%s", s);
        int len = (int) strlen(s);
        if (s[0] == '0' && s[len - 1] == '0') printf("fmc\n");
        else printf("gubo\n");
}
